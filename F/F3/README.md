# [F3 数字逻辑电路基础](https://ysyx.oscc.cc/docs/2407/f/3.html)

## 黄框题目
1.[搭建3位4选1选择器](https://ysyx.oscc.cc/docs/2407/f/3.html#%E7%BC%96%E7%A0%81%E5%99%A8)
    

> 尝试画出3位4选1选择器的电路结构图, 然后在Logisim中通过门电路搭建一个3位4选1选择器. 搭建后, 通过仿真检查你的方案是否正确.  
> **Hint:**
>- 如果你不理解"3位4选1选择器"的含义, 你需要先仔细阅读上文对"1位2选1选择器"的说明
>- 对于数据中的每一位, 都可以复用n选1译码器生成的选择信号进行选择

可能的解法：[F3_3-bit 4-to-1 selector]( F\F3\F3_3-bit_4-to-1_selector.circ )

<br>

2.[搭建可切换进位计数制的七段数码管器](https://ysyx.oscc.cc/docs/2407/f/3.html#%E7%BC%96%E7%A0%81%E5%99%A8)
    

>通过5个拨码开关和1个七段数码管, 实现如下功能: 其中4个拨码开关当作数据输入, 剩下1个拨码开关作为进位计数制的选择, 当选择信号为`0`时, 七段数码管以十进制方式显示数据; 当选择信号为`1`时, 七段数码管以十六进制方式显示数据. 在输入数据为10-15时, 两种显示方式有所不同.

可能的解法：

<br>

4.[搭建4位减法器](https://ysyx.oscc.cc/docs/2407/f/3.html#%E5%8E%9F%E7%A0%81-sign-and-magnitude)


>根据4位加法器的设计思路, 尝试在Logisim中通过门电路搭建一个4位减法器, 用七段数码管按十六进制显示减法器的两个输入和结果, 并用一个LED灯指示减法结果是否产生借位. 搭建后, 通过仿真检查你的方案是否正确.

可能的解法：

<br>

5.[搭建4位原码加法器](https://ysyx.oscc.cc/docs/2407/f/3.html#%E5%8E%9F%E7%A0%81-sign-and-magnitude)


>理解原码加法器的工作原理后, 尝试用加法器, 减法器和多路选择器等部件, 在Logisim中搭建一个4位原码加法器. 为了显示符号位, 你可以额外实例化一个七段数码管, 结果为负数时显示负号`-`, 否则不显示. 搭建后, 通过仿真检查你的方案是否正确.

可能的解法：

<br>

6.[搭建4位反码加法器](https://ysyx.oscc.cc/docs/2407/f/3.html#%E5%8F%8D%E7%A0%81-one-s-complement)


>尝试按照上述思路, 在Logisim中搭建一个4位反码加法器. 搭建后, 通过仿真检查你的方案是否正确.

可能的解法：


<br>

7.[检测补码加法是否发生溢出](https://ysyx.oscc.cc/docs/2407/f/3.html#%E6%BA%A2%E5%87%BA%E6%A3%80%E6%B5%8B)


>将上述真值表补充完整, 尝试列出溢出条件的逻辑表达式. 然后在Logisim中在4位加法器的基础上添加溢出判断逻辑. 添加后, 通过仿真检查你的方案是否正确.

可能的解法：

<br>

8.[搭建带复位功能的D锁存器](https://ysyx.oscc.cc/docs/2407/f/3.html#d%E9%94%81%E5%AD%98%E5%99%A8)


>尝试为D锁存器添加一个用于复位的输入端和复位功能. 当复位信号有效时, D锁存器中存放的值将变为`0`.

可能的解法：[F3_DL_with_reset_function.circ](F\F3\F3_DL_with_reset_function.circ)

<br>

9.[搭建带复位功能的D触发器](https://ysyx.oscc.cc/docs/2407/f/3.html#d%E8%A7%A6%E5%8F%91%E5%99%A8)


>尝试为D触发器添加一个用于复位的输入端和复位功能. 当复位信号有效时, D触发器中存放的值将变为`0`.

可能的解法：[F3_DFF_with_reset_function.circ](F\F3\F3_DFF_with_reset_function.circ)


<br>

10.[搭建带使能端的D触发器](https://ysyx.oscc.cc/docs/2407/f/3.html#d%E8%A7%A6%E5%8F%91%E5%99%A8)


>尝试在Logisim中通过D触发器和若干电路, 搭建一个带使能端的D触发器. 搭建后, 通过仿真检查你的方案是否正确.

可能的解法：[F3_DFF_with_enable.circ](F\F3\F3_DFF_with_enable.circ)


<br>

11.[搭建4位寄存器](https://ysyx.oscc.cc/docs/2407/f/3.html#%E5%AF%84%E5%AD%98%E5%99%A8)


>尝试在Logisim中通过D触发器搭建一个4位的寄存器, 具备复位功能. 搭建后, 尝试从拨码开关向寄存器写入4位数据, 并将寄存器的输出接到七段数码管进行显示.

可能的解法：[F3_4-bit_register.circ](F\F3\F3_4-bit_register.circ)


<br>

12.[搭建4位计数器](https://ysyx.oscc.cc/docs/2407/f/3.html#%E5%AF%84%E5%AD%98%E5%99%A8)


>通过上述4位寄存器和之前搭建的加法器, 实现一个4位计数器, 每次时钟到来时, 寄存器中的值加1, 加到最大值时重新从0开始. 在Logisim中, 你可以通过元件库中的`Wiring(线路)`类别下的`Constant(常数)`元件实例化一个常数, 具体使用方式请RTFM.

可能的解法：

<br>

13.[设计数列求和电路](https://ysyx.oscc.cc/docs/2407/f/3.html#%E5%AF%84%E5%AD%98%E5%99%A8)


>尝试通过寄存器和加法器, 计算出`1+2+...+10`的结果. 为了容纳计算结果, 你可以考虑实现8位的寄存器和加法器.

可能的解法：

<br>

14.[实现电子时钟](https://ysyx.oscc.cc/docs/2407/f/3.html#%E5%AF%84%E5%AD%98%E5%99%A8)


> 利用寄存器和七段数码管, 实现一个电子时钟, 具备"分"和"秒"的功能.  
> **Hint:** 
>- 使用`Clock(时钟)`元件可以自动产生时钟信号, 无需像按钮那样手动点击. 
>- 你可以在Logisim元件库的`Wiring(线路)`类别下找到它, 具体使用方式请RTFM.

可能的解法：










