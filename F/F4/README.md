# [F4 计算机系统的状态机模型](https://ysyx.oscc.cc/docs/2407/f/4.html)

## 题目
1.[继续执行上述指令](https://ysyx.oscc.cc/docs/2407/f/4.html#%E4%B8%80%E4%B8%AA%E6%95%B0%E5%88%97%E6%B1%82%E5%92%8C%E7%9A%84%E4%BE%8B%E5%AD%90)
>尝试继续执行指令, 记录寄存器的状态变化过程. 你发现执行到最后时, 处理器处于什么样的状态? 上述数列的求和结果在哪个寄存器中?

可能的解法：
```
(6,10,2,3,1)  
(4,10,2,3,1)  
(5,10,3,3,1)  
(6,10,3,6,1)  
(4,10,3,6,1)
(5,10,4,6,1)
(6,10,4,10,1)
(4,10,4,10,1)
(5,10,5,10,1)
(6,10,5,15,1)
(4,10,5,15,1)
(5,10,6,15,1)
(6,10,6,21,1)
(4,10,6,21,1)
(5,10,7,21,1)
(6,10,7,28,1)
(4,10,7,28,1)
(5,10,8,28,1)
(6,10,8,36,1)
(4,10,8,36,1)
(5,10,9,36,1)
(6,10,9,45,1)
(4,10,9,45,1)
(5,10,10,45,1)
(6,10,10,55,1)
(7,10,10,55,1)
```
> 故求和结果在r2寄存器中

<br>

2.[计算10以内的奇数之和](https://ysyx.oscc.cc/docs/2407/f/4.html#%E4%B8%80%E4%B8%AA%E6%95%B0%E5%88%97%E6%B1%82%E5%92%8C%E7%9A%84%E4%BE%8B%E5%AD%90)
>尝试用上述指令编写一个程序, 求出10以内的奇数之和, 即计算`1+3+5+7+9`. 编写后, 尝试列出处理器状态的变化过程, 以此来检查你编写的程序是否正确.

可能的解法：
```
0: li r0 11
1: li r1 1
2: li r2 0
3: li r3 2
4: add r2 r2 r1
5: add r1 r1 r3
6: bner0 r1 4
7: bner0 r3 7
```
```
PC r0 r1 r2 r3
(0,0,0,0,0)
(1,11,0,0,0)
(2,11,1,0,0)
(3,11,1,0,0)
(4,11,1,0,2)
(5,11,1,1,2)
(6,11,3,1,2)
(4,11,3,1,2)
(5,11,3,4,2)
(6,11,5,4,2)
(4,11,5,4,2)
(5,11,5,9,2)
(6,11,7,9,2)
(4,11,7,9,2)
(5,11,7,16,2)
(6,11,9,16,2)
(4,11,9,16,2)
(5,11,9,25,2)
(6,11,11,25,2)
(7,11,11,25,2)
```

<br>

3.[继续执行上述程序](https://ysyx.oscc.cc/docs/2407/f/4.html#%E7%94%A8c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E6%95%B0%E5%88%97%E6%B1%82%E5%92%8C)
>尝试继续执行上述代码, 记录状态的变化过程. 程序执行结束时, 程序处于什么样的状态?

可能的解法：
```
过程略
结束时
(9,55,11)
```

<br>

4.[从状态机视角理解数列求和电路的工作过程](https://ysyx.oscc.cc/docs/2407/f/4.html#%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%BA%E6%A8%A1%E5%9E%8B)
>在上一小节中, 你已经通过寄存器和加法器搭建出一个简单数列求和电路, 用于计算`1+2+...+10`. 尝试列出电路状态的变化过程.

可能的解法：
>根据[F3_Sequence_summation_circuit.circ](F3_Sequence_summation_circuit.circ)

```
A(DEC) B/S(DEC)
(0,0)
(1,0)
(2,1)
(3,3)
(4,6)
(5,10)
(6,15)
(7,21)
(8,28)
(9,36)
(10,45)
(11,55)
```


